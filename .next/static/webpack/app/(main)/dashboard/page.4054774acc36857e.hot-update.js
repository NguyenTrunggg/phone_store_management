"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(main)/dashboard/page",{

/***/ "(app-pages-browser)/./src/lib/firebase/services/dashboard.service.ts":
/*!********************************************************!*\
  !*** ./src/lib/firebase/services/dashboard.service.ts ***!
  \********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DashboardService: function() { return /* binding */ DashboardService; },\n/* harmony export */   dashboardService: function() { return /* binding */ dashboardService; }\n/* harmony export */ });\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var _lib_firebase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/firebase */ \"(app-pages-browser)/./src/lib/firebase.ts\");\n/* harmony import */ var _base_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base.service */ \"(app-pages-browser)/./src/lib/firebase/services/base.service.ts\");\n/* harmony import */ var _pos_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pos.service */ \"(app-pages-browser)/./src/lib/firebase/services/pos.service.ts\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/constants */ \"(app-pages-browser)/./src/constants/index.ts\");\n\n\n\n\n\nclass DashboardService extends _base_service__WEBPACK_IMPORTED_MODULE_2__.BaseService {\n    async getStatsForDateRange(startDate, endDate) {\n        const ordersRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_lib_firebase__WEBPACK_IMPORTED_MODULE_1__.db, _constants__WEBPACK_IMPORTED_MODULE_4__.COLLECTIONS.SALES_ORDERS);\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(ordersRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"orderDate\", \">=\", firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.Timestamp.fromDate(startDate)), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"orderDate\", \"<=\", firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.Timestamp.fromDate(endDate)));\n        const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n        let revenue = 0;\n        const customerIds = new Set();\n        snapshot.docs.forEach((doc)=>{\n            var _order_customerInfo;\n            const order = doc.data();\n            revenue += order.totalAmount;\n            if (order.customerId) {\n                customerIds.add(order.customerId);\n            } else if ((_order_customerInfo = order.customerInfo) === null || _order_customerInfo === void 0 ? void 0 : _order_customerInfo.phone) {\n                // Fallback to phone if customerId is not present\n                customerIds.add(order.customerInfo.phone);\n            }\n        });\n        return {\n            revenue,\n            orders: snapshot.size,\n            customers: customerIds\n        };\n    }\n    calculatePercentageChange(current, previous) {\n        if (previous === 0) {\n            return current > 0 ? 100 : 0;\n        }\n        return (current - previous) / previous * 100;\n    }\n    async getDashboardStats() {\n        let lowStockThreshold = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5, monthlyTarget = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2500000000;\n        try {\n            const now = new Date();\n            const startOfToday = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0);\n            const endOfToday = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59);\n            const yesterday = new Date(now);\n            yesterday.setDate(now.getDate() - 1);\n            const startOfYesterday = new Date(yesterday.getFullYear(), yesterday.getMonth(), yesterday.getDate(), 0, 0, 0);\n            const endOfYesterday = new Date(yesterday.getFullYear(), yesterday.getMonth(), yesterday.getDate(), 23, 59, 59);\n            const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);\n            const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59);\n            // --- 1. Today's & Yesterday's Stats ---\n            const [todayStatsData, yesterdayStatsData] = await Promise.all([\n                this.getStatsForDateRange(startOfToday, endOfToday),\n                this.getStatsForDateRange(startOfYesterday, endOfYesterday)\n            ]);\n            const todayAvgOrderValue = todayStatsData.orders > 0 ? todayStatsData.revenue / todayStatsData.orders : 0;\n            const yesterdayAvgOrderValue = yesterdayStatsData.orders > 0 ? yesterdayStatsData.revenue / yesterdayStatsData.orders : 0;\n            const todayStats = {\n                revenue: todayStatsData.revenue,\n                orders: todayStatsData.orders,\n                avgOrderValue: todayAvgOrderValue,\n                customers: todayStatsData.customers.size,\n                revenueChange: this.calculatePercentageChange(todayStatsData.revenue, yesterdayStatsData.revenue),\n                ordersChange: this.calculatePercentageChange(todayStatsData.orders, yesterdayStatsData.orders),\n                avgOrderValueChange: this.calculatePercentageChange(todayAvgOrderValue, yesterdayAvgOrderValue),\n                customersChange: this.calculatePercentageChange(todayStatsData.customers.size, yesterdayStatsData.customers.size)\n            };\n            // --- 2. Inventory Alerts ---\n            const availableProductsResponse = await _pos_service__WEBPACK_IMPORTED_MODULE_3__.posService.getAvailableProductsForSale();\n            if (!availableProductsResponse.success || !availableProductsResponse.data) {\n                throw new Error(\"Could not fetch available products for inventory alerts.\");\n            }\n            const inventoryAlerts = [];\n            availableProductsResponse.data.forEach((product)=>{\n                product.variants.forEach((variant)=>{\n                    if (variant.totalStock <= lowStockThreshold) {\n                        inventoryAlerts.push({\n                            model: product.productName,\n                            variant: \"\".concat(variant.storageCapacity, \" \").concat(variant.colorName),\n                            stock: variant.totalStock,\n                            status: variant.totalStock === 0 ? \"out\" : \"low\"\n                        });\n                    }\n                });\n            });\n            // --- 3. Top Selling Products Today ---\n            // Using collectionGroup query on order items\n            const itemsRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collectionGroup)(_lib_firebase__WEBPACK_IMPORTED_MODULE_1__.db, _constants__WEBPACK_IMPORTED_MODULE_4__.SUBCOLLECTIONS.ORDER_ITEMS);\n            const itemsQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(itemsRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"createdAt\", \">=\", firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.Timestamp.fromDate(startOfToday)), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"createdAt\", \"<=\", firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.Timestamp.fromDate(endOfToday)));\n            const itemsSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(itemsQuery);\n            const productSales = new Map();\n            itemsSnapshot.docs.forEach((doc)=>{\n                const item = doc.data();\n                // Defensive check: Ensure the item and its key fields are valid\n                if (!item || !item.variantId || !item.productName) {\n                    console.warn(\"Skipping malformed order item from Firestore:\", doc.id);\n                    return; // Skip this document\n                }\n                const key = item.variantId;\n                const name = \"\".concat(item.productName, \" \").concat(item.storageCapacity || \"\");\n                if (!productSales.has(key)) {\n                    productSales.set(key, {\n                        name: name,\n                        sold: 0,\n                        revenue: 0\n                    });\n                }\n                const product = productSales.get(key);\n                // Use default value 0 if quantity or finalPrice are missing/falsy\n                product.sold += item.quantity || 0;\n                product.revenue += item.finalPrice || 0;\n            });\n            const topProducts = Array.from(productSales.values()).sort((a, b)=>b.revenue - a.revenue).slice(0, 5); // Get top 5\n            // --- 4. Monthly Revenue ---\n            const monthlyStats = await this.getStatsForDateRange(startOfMonth, endOfMonth);\n            const monthlyRevenue = {\n                current: monthlyStats.revenue,\n                target: monthlyTarget,\n                progress: monthlyTarget > 0 ? monthlyStats.revenue / monthlyTarget * 100 : 0\n            };\n            // --- Combine all data ---\n            const dashboardData = {\n                todayStats,\n                inventoryAlerts,\n                topProducts,\n                monthlyRevenue\n            };\n            return {\n                success: true,\n                data: dashboardData\n            };\n        } catch (error) {\n            return this.handleError(error);\n        }\n    }\n    constructor(){\n        super(\"dashboard\"); // Not a real collection, just for base class\n    }\n}\nconst dashboardService = new DashboardService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvZmlyZWJhc2Uvc2VydmljZXMvZGFzaGJvYXJkLnNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQU80QjtBQUNRO0FBQzBCO0FBQ25CO0FBRWU7QUF3Q25ELE1BQU1XLHlCQUF5Qkosc0RBQVdBO0lBSy9DLE1BQWNLLHFCQUNaQyxTQUFlLEVBQ2ZDLE9BQWEsRUFDeUQ7UUFDdEUsTUFBTUMsWUFBWWYsOERBQVVBLENBQUNNLDZDQUFFQSxFQUFFRyxtREFBV0EsQ0FBQ08sWUFBWTtRQUN6RCxNQUFNQyxJQUFJZix5REFBS0EsQ0FDYmEsV0FDQVoseURBQUtBLENBQUMsYUFBYSxNQUFNRSx5REFBU0EsQ0FBQ2EsUUFBUSxDQUFDTCxhQUM1Q1YseURBQUtBLENBQUMsYUFBYSxNQUFNRSx5REFBU0EsQ0FBQ2EsUUFBUSxDQUFDSjtRQUU5QyxNQUFNSyxXQUFXLE1BQU1mLDJEQUFPQSxDQUFDYTtRQUUvQixJQUFJRyxVQUFVO1FBQ2QsTUFBTUMsY0FBYyxJQUFJQztRQUV4QkgsU0FBU0ksSUFBSSxDQUFDQyxPQUFPLENBQUMsQ0FBQ0M7Z0JBS1ZDO1lBSlgsTUFBTUEsUUFBUUQsSUFBSUUsSUFBSTtZQUN0QlAsV0FBV00sTUFBTUUsV0FBVztZQUM1QixJQUFJRixNQUFNRyxVQUFVLEVBQUU7Z0JBQ3BCUixZQUFZUyxHQUFHLENBQUNKLE1BQU1HLFVBQVU7WUFDbEMsT0FBTyxLQUFJSCxzQkFBQUEsTUFBTUssWUFBWSxjQUFsQkwsMENBQUFBLG9CQUFvQk0sS0FBSyxFQUFFO2dCQUNwQyxpREFBaUQ7Z0JBQ2pEWCxZQUFZUyxHQUFHLENBQUNKLE1BQU1LLFlBQVksQ0FBQ0MsS0FBSztZQUMxQztRQUNGO1FBRUEsT0FBTztZQUNMWjtZQUNBYSxRQUFRZCxTQUFTZSxJQUFJO1lBQ3JCQyxXQUFXZDtRQUNiO0lBQ0Y7SUFFUWUsMEJBQTBCQyxPQUFlLEVBQUVDLFFBQWdCLEVBQVU7UUFDM0UsSUFBSUEsYUFBYSxHQUFHO1lBQ2xCLE9BQU9ELFVBQVUsSUFBSSxNQUFNO1FBQzdCO1FBQ0EsT0FBTyxDQUFFQSxVQUFVQyxRQUFPLElBQUtBLFdBQVk7SUFDN0M7SUFFQSxNQUFNQyxvQkFHcUM7WUFGekNDLG9CQUFBQSxpRUFBNEIsR0FDNUJDLGdCQUFBQSxpRUFBd0I7UUFFeEIsSUFBSTtZQUNGLE1BQU1DLE1BQU0sSUFBSUM7WUFDaEIsTUFBTUMsZUFBZSxJQUFJRCxLQUN2QkQsSUFBSUcsV0FBVyxJQUNmSCxJQUFJSSxRQUFRLElBQ1pKLElBQUlLLE9BQU8sSUFDWCxHQUNBLEdBQ0E7WUFFRixNQUFNQyxhQUFhLElBQUlMLEtBQ3JCRCxJQUFJRyxXQUFXLElBQ2ZILElBQUlJLFFBQVEsSUFDWkosSUFBSUssT0FBTyxJQUNYLElBQ0EsSUFDQTtZQUdGLE1BQU1FLFlBQVksSUFBSU4sS0FBS0Q7WUFDM0JPLFVBQVVDLE9BQU8sQ0FBQ1IsSUFBSUssT0FBTyxLQUFLO1lBQ2xDLE1BQU1JLG1CQUFtQixJQUFJUixLQUMzQk0sVUFBVUosV0FBVyxJQUNyQkksVUFBVUgsUUFBUSxJQUNsQkcsVUFBVUYsT0FBTyxJQUNqQixHQUNBLEdBQ0E7WUFFRixNQUFNSyxpQkFBaUIsSUFBSVQsS0FDekJNLFVBQVVKLFdBQVcsSUFDckJJLFVBQVVILFFBQVEsSUFDbEJHLFVBQVVGLE9BQU8sSUFDakIsSUFDQSxJQUNBO1lBR0YsTUFBTU0sZUFBZSxJQUFJVixLQUFLRCxJQUFJRyxXQUFXLElBQUlILElBQUlJLFFBQVEsSUFBSTtZQUNqRSxNQUFNUSxhQUFhLElBQUlYLEtBQ3JCRCxJQUFJRyxXQUFXLElBQ2ZILElBQUlJLFFBQVEsS0FBSyxHQUNqQixHQUNBLElBQ0EsSUFDQTtZQUdGLHlDQUF5QztZQUN6QyxNQUFNLENBQUNTLGdCQUFnQkMsbUJBQW1CLEdBQUcsTUFBTUMsUUFBUUMsR0FBRyxDQUFDO2dCQUM3RCxJQUFJLENBQUM5QyxvQkFBb0IsQ0FBQ2dDLGNBQWNJO2dCQUN4QyxJQUFJLENBQUNwQyxvQkFBb0IsQ0FBQ3VDLGtCQUFrQkM7YUFDN0M7WUFFRCxNQUFNTyxxQkFDSkosZUFBZXRCLE1BQU0sR0FBRyxJQUNwQnNCLGVBQWVuQyxPQUFPLEdBQUdtQyxlQUFldEIsTUFBTSxHQUM5QztZQUNOLE1BQU0yQix5QkFDSkosbUJBQW1CdkIsTUFBTSxHQUFHLElBQ3hCdUIsbUJBQW1CcEMsT0FBTyxHQUFHb0MsbUJBQW1CdkIsTUFBTSxHQUN0RDtZQUVOLE1BQU00QixhQUF5QjtnQkFDN0J6QyxTQUFTbUMsZUFBZW5DLE9BQU87Z0JBQy9CYSxRQUFRc0IsZUFBZXRCLE1BQU07Z0JBQzdCNkIsZUFBZUg7Z0JBQ2Z4QixXQUFXb0IsZUFBZXBCLFNBQVMsQ0FBQ0QsSUFBSTtnQkFDeEM2QixlQUFlLElBQUksQ0FBQzNCLHlCQUF5QixDQUMzQ21CLGVBQWVuQyxPQUFPLEVBQ3RCb0MsbUJBQW1CcEMsT0FBTztnQkFFNUI0QyxjQUFjLElBQUksQ0FBQzVCLHlCQUF5QixDQUMxQ21CLGVBQWV0QixNQUFNLEVBQ3JCdUIsbUJBQW1CdkIsTUFBTTtnQkFFM0JnQyxxQkFBcUIsSUFBSSxDQUFDN0IseUJBQXlCLENBQ2pEdUIsb0JBQ0FDO2dCQUVGTSxpQkFBaUIsSUFBSSxDQUFDOUIseUJBQXlCLENBQzdDbUIsZUFBZXBCLFNBQVMsQ0FBQ0QsSUFBSSxFQUM3QnNCLG1CQUFtQnJCLFNBQVMsQ0FBQ0QsSUFBSTtZQUVyQztZQUVBLDhCQUE4QjtZQUM5QixNQUFNaUMsNEJBQ0osTUFBTTNELG9EQUFVQSxDQUFDNEQsMkJBQTJCO1lBQzlDLElBQUksQ0FBQ0QsMEJBQTBCRSxPQUFPLElBQUksQ0FBQ0YsMEJBQTBCeEMsSUFBSSxFQUFFO2dCQUN6RSxNQUFNLElBQUkyQyxNQUFNO1lBQ2xCO1lBRUEsTUFBTUMsa0JBQW9DLEVBQUU7WUFDNUNKLDBCQUEwQnhDLElBQUksQ0FBQ0gsT0FBTyxDQUFDLENBQUNnRDtnQkFDdENBLFFBQVFDLFFBQVEsQ0FBQ2pELE9BQU8sQ0FBQyxDQUFDa0Q7b0JBQ3hCLElBQUlBLFFBQVFDLFVBQVUsSUFBSW5DLG1CQUFtQjt3QkFDM0MrQixnQkFBZ0JLLElBQUksQ0FBQzs0QkFDbkJDLE9BQU9MLFFBQVFNLFdBQVc7NEJBQzFCSixTQUFTLEdBQThCQSxPQUEzQkEsUUFBUUssZUFBZSxFQUFDLEtBQXFCLE9BQWxCTCxRQUFRTSxTQUFTOzRCQUN4REMsT0FBT1AsUUFBUUMsVUFBVTs0QkFDekJPLFFBQVFSLFFBQVFDLFVBQVUsS0FBSyxJQUFJLFFBQVE7d0JBQzdDO29CQUNGO2dCQUNGO1lBQ0Y7WUFFQSx3Q0FBd0M7WUFDeEMsNkNBQTZDO1lBQzdDLE1BQU1RLFdBQVdsRixtRUFBZUEsQ0FBQ0ssNkNBQUVBLEVBQUVJLHNEQUFjQSxDQUFDMEUsV0FBVztZQUMvRCxNQUFNQyxhQUFhbkYseURBQUtBLENBQ3RCaUYsVUFDQWhGLHlEQUFLQSxDQUFDLGFBQWEsTUFBTUUseURBQVNBLENBQUNhLFFBQVEsQ0FBQzBCLGdCQUM1Q3pDLHlEQUFLQSxDQUFDLGFBQWEsTUFBTUUseURBQVNBLENBQUNhLFFBQVEsQ0FBQzhCO1lBRTlDLE1BQU1zQyxnQkFBZ0IsTUFBTWxGLDJEQUFPQSxDQUFDaUY7WUFFcEMsTUFBTUUsZUFBZSxJQUFJQztZQUt6QkYsY0FBYy9ELElBQUksQ0FBQ0MsT0FBTyxDQUFDLENBQUNDO2dCQUMxQixNQUFNZ0UsT0FBT2hFLElBQUlFLElBQUk7Z0JBRXJCLGdFQUFnRTtnQkFDaEUsSUFBSSxDQUFDOEQsUUFBUSxDQUFDQSxLQUFLQyxTQUFTLElBQUksQ0FBQ0QsS0FBS1gsV0FBVyxFQUFFO29CQUNqRGEsUUFBUUMsSUFBSSxDQUFDLGlEQUFpRG5FLElBQUlvRSxFQUFFO29CQUNwRSxRQUFRLHFCQUFxQjtnQkFDL0I7Z0JBRUEsTUFBTUMsTUFBTUwsS0FBS0MsU0FBUztnQkFDMUIsTUFBTUssT0FBTyxHQUF1Qk4sT0FBcEJBLEtBQUtYLFdBQVcsRUFBQyxLQUE4QixPQUEzQlcsS0FBS1YsZUFBZSxJQUFJO2dCQUU1RCxJQUFJLENBQUNRLGFBQWFTLEdBQUcsQ0FBQ0YsTUFBTTtvQkFDMUJQLGFBQWFVLEdBQUcsQ0FBQ0gsS0FBSzt3QkFBRUMsTUFBTUE7d0JBQU1HLE1BQU07d0JBQUc5RSxTQUFTO29CQUFFO2dCQUMxRDtnQkFFQSxNQUFNb0QsVUFBVWUsYUFBYVksR0FBRyxDQUFDTDtnQkFFakMsa0VBQWtFO2dCQUNsRXRCLFFBQVEwQixJQUFJLElBQUlULEtBQUtXLFFBQVEsSUFBSTtnQkFDakM1QixRQUFRcEQsT0FBTyxJQUFJcUUsS0FBS1ksVUFBVSxJQUFJO1lBQ3hDO1lBRUEsTUFBTUMsY0FBNEJDLE1BQU1DLElBQUksQ0FBQ2pCLGFBQWFrQixNQUFNLElBQzdEQyxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUEsRUFBRXhGLE9BQU8sR0FBR3VGLEVBQUV2RixPQUFPLEVBQ3BDeUYsS0FBSyxDQUFDLEdBQUcsSUFBSSxZQUFZO1lBRTVCLDZCQUE2QjtZQUM3QixNQUFNQyxlQUFlLE1BQU0sSUFBSSxDQUFDbEcsb0JBQW9CLENBQ2xEeUMsY0FDQUM7WUFFRixNQUFNeUQsaUJBQWlDO2dCQUNyQzFFLFNBQVN5RSxhQUFhMUYsT0FBTztnQkFDN0I0RixRQUFRdkU7Z0JBQ1J3RSxVQUNFeEUsZ0JBQWdCLElBQUksYUFBY3JCLE9BQU8sR0FBR3FCLGdCQUFpQixNQUFNO1lBQ3ZFO1lBRUEsMkJBQTJCO1lBQzNCLE1BQU15RSxnQkFBK0I7Z0JBQ25DckQ7Z0JBQ0FVO2dCQUNBK0I7Z0JBQ0FTO1lBQ0Y7WUFFQSxPQUFPO2dCQUFFMUMsU0FBUztnQkFBTTFDLE1BQU11RjtZQUFjO1FBQzlDLEVBQUUsT0FBT0MsT0FBTztZQUNkLE9BQU8sSUFBSSxDQUFDQyxXQUFXLENBQUNEO1FBQzFCO0lBQ0Y7SUE3TkFFLGFBQWM7UUFDWixLQUFLLENBQUMsY0FBYyw2Q0FBNkM7SUFDbkU7QUE0TkY7QUFFTyxNQUFNQyxtQkFBbUIsSUFBSTNHLG1CQUFtQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL2ZpcmViYXNlL3NlcnZpY2VzL2Rhc2hib2FyZC5zZXJ2aWNlLnRzPzRkMjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICBjb2xsZWN0aW9uLFxyXG4gIGNvbGxlY3Rpb25Hcm91cCxcclxuICBxdWVyeSxcclxuICB3aGVyZSxcclxuICBnZXREb2NzLFxyXG4gIFRpbWVzdGFtcCxcclxufSBmcm9tIFwiZmlyZWJhc2UvZmlyZXN0b3JlXCI7XHJcbmltcG9ydCB7IGRiIH0gZnJvbSBcIkAvbGliL2ZpcmViYXNlXCI7XHJcbmltcG9ydCB7IEJhc2VTZXJ2aWNlLCBTZXJ2aWNlUmVzcG9uc2UgfSBmcm9tIFwiLi9iYXNlLnNlcnZpY2VcIjtcclxuaW1wb3J0IHsgcG9zU2VydmljZSB9IGZyb20gXCIuL3Bvcy5zZXJ2aWNlXCI7XHJcbmltcG9ydCB7IEZpcmViYXNlU2FsZXNPcmRlciwgRmlyZWJhc2VTYWxlc09yZGVySXRlbSB9IGZyb20gXCIuLi9tb2RlbHMvcG9zLm1vZGVsXCI7XHJcbmltcG9ydCB7IENPTExFQ1RJT05TLCBTVUJDT0xMRUNUSU9OUyB9IGZyb20gXCJAL2NvbnN0YW50c1wiO1xyXG5cclxuLy8gRGF0YSBzdHJ1Y3R1cmVzIGZvciB0aGUgZGFzaGJvYXJkXHJcbmV4cG9ydCBpbnRlcmZhY2UgVG9kYXlTdGF0cyB7XHJcbiAgcmV2ZW51ZTogbnVtYmVyO1xyXG4gIG9yZGVyczogbnVtYmVyO1xyXG4gIGF2Z09yZGVyVmFsdWU6IG51bWJlcjtcclxuICBjdXN0b21lcnM6IG51bWJlcjtcclxuICByZXZlbnVlQ2hhbmdlOiBudW1iZXI7IC8vIFBlcmNlbnRhZ2UgY2hhbmdlIGZyb20geWVzdGVyZGF5XHJcbiAgb3JkZXJzQ2hhbmdlOiBudW1iZXI7IC8vIFBlcmNlbnRhZ2UgY2hhbmdlXHJcbiAgYXZnT3JkZXJWYWx1ZUNoYW5nZTogbnVtYmVyOyAvLyBQZXJjZW50YWdlIGNoYW5nZVxyXG4gIGN1c3RvbWVyc0NoYW5nZTogbnVtYmVyOyAvLyBQZXJjZW50YWdlIGNoYW5nZVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEludmVudG9yeUFsZXJ0IHtcclxuICBtb2RlbDogc3RyaW5nO1xyXG4gIHZhcmlhbnQ6IHN0cmluZztcclxuICBzdG9jazogbnVtYmVyO1xyXG4gIHN0YXR1czogXCJsb3dcIiB8IFwib3V0XCI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVG9wUHJvZHVjdCB7XHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIHNvbGQ6IG51bWJlcjtcclxuICByZXZlbnVlOiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTW9udGhseVJldmVudWUge1xyXG4gIGN1cnJlbnQ6IG51bWJlcjtcclxuICB0YXJnZXQ6IG51bWJlcjtcclxuICBwcm9ncmVzczogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIERhc2hib2FyZERhdGEge1xyXG4gIHRvZGF5U3RhdHM6IFRvZGF5U3RhdHM7XHJcbiAgaW52ZW50b3J5QWxlcnRzOiBJbnZlbnRvcnlBbGVydFtdO1xyXG4gIHRvcFByb2R1Y3RzOiBUb3BQcm9kdWN0W107XHJcbiAgbW9udGhseVJldmVudWU6IE1vbnRobHlSZXZlbnVlO1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgRGFzaGJvYXJkU2VydmljZSBleHRlbmRzIEJhc2VTZXJ2aWNlIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKFwiZGFzaGJvYXJkXCIpOyAvLyBOb3QgYSByZWFsIGNvbGxlY3Rpb24sIGp1c3QgZm9yIGJhc2UgY2xhc3NcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgZ2V0U3RhdHNGb3JEYXRlUmFuZ2UoXHJcbiAgICBzdGFydERhdGU6IERhdGUsXHJcbiAgICBlbmREYXRlOiBEYXRlXHJcbiAgKTogUHJvbWlzZTx7IHJldmVudWU6IG51bWJlcjsgb3JkZXJzOiBudW1iZXI7IGN1c3RvbWVyczogU2V0PHN0cmluZz4gfT4ge1xyXG4gICAgY29uc3Qgb3JkZXJzUmVmID0gY29sbGVjdGlvbihkYiwgQ09MTEVDVElPTlMuU0FMRVNfT1JERVJTKTtcclxuICAgIGNvbnN0IHEgPSBxdWVyeShcclxuICAgICAgb3JkZXJzUmVmLFxyXG4gICAgICB3aGVyZShcIm9yZGVyRGF0ZVwiLCBcIj49XCIsIFRpbWVzdGFtcC5mcm9tRGF0ZShzdGFydERhdGUpKSxcclxuICAgICAgd2hlcmUoXCJvcmRlckRhdGVcIiwgXCI8PVwiLCBUaW1lc3RhbXAuZnJvbURhdGUoZW5kRGF0ZSkpXHJcbiAgICApO1xyXG4gICAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHEpO1xyXG5cclxuICAgIGxldCByZXZlbnVlID0gMDtcclxuICAgIGNvbnN0IGN1c3RvbWVySWRzID0gbmV3IFNldDxzdHJpbmc+KCk7XHJcblxyXG4gICAgc25hcHNob3QuZG9jcy5mb3JFYWNoKChkb2MpID0+IHtcclxuICAgICAgY29uc3Qgb3JkZXIgPSBkb2MuZGF0YSgpIGFzIEZpcmViYXNlU2FsZXNPcmRlcjtcclxuICAgICAgcmV2ZW51ZSArPSBvcmRlci50b3RhbEFtb3VudDtcclxuICAgICAgaWYgKG9yZGVyLmN1c3RvbWVySWQpIHtcclxuICAgICAgICBjdXN0b21lcklkcy5hZGQob3JkZXIuY3VzdG9tZXJJZCk7XHJcbiAgICAgIH0gZWxzZSBpZiAob3JkZXIuY3VzdG9tZXJJbmZvPy5waG9uZSkge1xyXG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIHBob25lIGlmIGN1c3RvbWVySWQgaXMgbm90IHByZXNlbnRcclxuICAgICAgICBjdXN0b21lcklkcy5hZGQob3JkZXIuY3VzdG9tZXJJbmZvLnBob25lKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcmV2ZW51ZSxcclxuICAgICAgb3JkZXJzOiBzbmFwc2hvdC5zaXplLFxyXG4gICAgICBjdXN0b21lcnM6IGN1c3RvbWVySWRzLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgY2FsY3VsYXRlUGVyY2VudGFnZUNoYW5nZShjdXJyZW50OiBudW1iZXIsIHByZXZpb3VzOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgaWYgKHByZXZpb3VzID09PSAwKSB7XHJcbiAgICAgIHJldHVybiBjdXJyZW50ID4gMCA/IDEwMCA6IDA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKChjdXJyZW50IC0gcHJldmlvdXMpIC8gcHJldmlvdXMpICogMTAwO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0RGFzaGJvYXJkU3RhdHMoXHJcbiAgICBsb3dTdG9ja1RocmVzaG9sZDogbnVtYmVyID0gNSxcclxuICAgIG1vbnRobHlUYXJnZXQ6IG51bWJlciA9IDI1MDAwMDAwMDBcclxuICApOiBQcm9taXNlPFNlcnZpY2VSZXNwb25zZTxEYXNoYm9hcmREYXRhPj4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcclxuICAgICAgY29uc3Qgc3RhcnRPZlRvZGF5ID0gbmV3IERhdGUoXHJcbiAgICAgICAgbm93LmdldEZ1bGxZZWFyKCksXHJcbiAgICAgICAgbm93LmdldE1vbnRoKCksXHJcbiAgICAgICAgbm93LmdldERhdGUoKSxcclxuICAgICAgICAwLFxyXG4gICAgICAgIDAsXHJcbiAgICAgICAgMFxyXG4gICAgICApO1xyXG4gICAgICBjb25zdCBlbmRPZlRvZGF5ID0gbmV3IERhdGUoXHJcbiAgICAgICAgbm93LmdldEZ1bGxZZWFyKCksXHJcbiAgICAgICAgbm93LmdldE1vbnRoKCksXHJcbiAgICAgICAgbm93LmdldERhdGUoKSxcclxuICAgICAgICAyMyxcclxuICAgICAgICA1OSxcclxuICAgICAgICA1OVxyXG4gICAgICApO1xyXG5cclxuICAgICAgY29uc3QgeWVzdGVyZGF5ID0gbmV3IERhdGUobm93KTtcclxuICAgICAgeWVzdGVyZGF5LnNldERhdGUobm93LmdldERhdGUoKSAtIDEpO1xyXG4gICAgICBjb25zdCBzdGFydE9mWWVzdGVyZGF5ID0gbmV3IERhdGUoXHJcbiAgICAgICAgeWVzdGVyZGF5LmdldEZ1bGxZZWFyKCksXHJcbiAgICAgICAgeWVzdGVyZGF5LmdldE1vbnRoKCksXHJcbiAgICAgICAgeWVzdGVyZGF5LmdldERhdGUoKSxcclxuICAgICAgICAwLFxyXG4gICAgICAgIDAsXHJcbiAgICAgICAgMFxyXG4gICAgICApO1xyXG4gICAgICBjb25zdCBlbmRPZlllc3RlcmRheSA9IG5ldyBEYXRlKFxyXG4gICAgICAgIHllc3RlcmRheS5nZXRGdWxsWWVhcigpLFxyXG4gICAgICAgIHllc3RlcmRheS5nZXRNb250aCgpLFxyXG4gICAgICAgIHllc3RlcmRheS5nZXREYXRlKCksXHJcbiAgICAgICAgMjMsXHJcbiAgICAgICAgNTksXHJcbiAgICAgICAgNTlcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGNvbnN0IHN0YXJ0T2ZNb250aCA9IG5ldyBEYXRlKG5vdy5nZXRGdWxsWWVhcigpLCBub3cuZ2V0TW9udGgoKSwgMSk7XHJcbiAgICAgIGNvbnN0IGVuZE9mTW9udGggPSBuZXcgRGF0ZShcclxuICAgICAgICBub3cuZ2V0RnVsbFllYXIoKSxcclxuICAgICAgICBub3cuZ2V0TW9udGgoKSArIDEsXHJcbiAgICAgICAgMCxcclxuICAgICAgICAyMyxcclxuICAgICAgICA1OSxcclxuICAgICAgICA1OVxyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gLS0tIDEuIFRvZGF5J3MgJiBZZXN0ZXJkYXkncyBTdGF0cyAtLS1cclxuICAgICAgY29uc3QgW3RvZGF5U3RhdHNEYXRhLCB5ZXN0ZXJkYXlTdGF0c0RhdGFdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgIHRoaXMuZ2V0U3RhdHNGb3JEYXRlUmFuZ2Uoc3RhcnRPZlRvZGF5LCBlbmRPZlRvZGF5KSxcclxuICAgICAgICB0aGlzLmdldFN0YXRzRm9yRGF0ZVJhbmdlKHN0YXJ0T2ZZZXN0ZXJkYXksIGVuZE9mWWVzdGVyZGF5KSxcclxuICAgICAgXSk7XHJcblxyXG4gICAgICBjb25zdCB0b2RheUF2Z09yZGVyVmFsdWUgPVxyXG4gICAgICAgIHRvZGF5U3RhdHNEYXRhLm9yZGVycyA+IDBcclxuICAgICAgICAgID8gdG9kYXlTdGF0c0RhdGEucmV2ZW51ZSAvIHRvZGF5U3RhdHNEYXRhLm9yZGVyc1xyXG4gICAgICAgICAgOiAwO1xyXG4gICAgICBjb25zdCB5ZXN0ZXJkYXlBdmdPcmRlclZhbHVlID1cclxuICAgICAgICB5ZXN0ZXJkYXlTdGF0c0RhdGEub3JkZXJzID4gMFxyXG4gICAgICAgICAgPyB5ZXN0ZXJkYXlTdGF0c0RhdGEucmV2ZW51ZSAvIHllc3RlcmRheVN0YXRzRGF0YS5vcmRlcnNcclxuICAgICAgICAgIDogMDtcclxuXHJcbiAgICAgIGNvbnN0IHRvZGF5U3RhdHM6IFRvZGF5U3RhdHMgPSB7XHJcbiAgICAgICAgcmV2ZW51ZTogdG9kYXlTdGF0c0RhdGEucmV2ZW51ZSxcclxuICAgICAgICBvcmRlcnM6IHRvZGF5U3RhdHNEYXRhLm9yZGVycyxcclxuICAgICAgICBhdmdPcmRlclZhbHVlOiB0b2RheUF2Z09yZGVyVmFsdWUsXHJcbiAgICAgICAgY3VzdG9tZXJzOiB0b2RheVN0YXRzRGF0YS5jdXN0b21lcnMuc2l6ZSxcclxuICAgICAgICByZXZlbnVlQ2hhbmdlOiB0aGlzLmNhbGN1bGF0ZVBlcmNlbnRhZ2VDaGFuZ2UoXHJcbiAgICAgICAgICB0b2RheVN0YXRzRGF0YS5yZXZlbnVlLFxyXG4gICAgICAgICAgeWVzdGVyZGF5U3RhdHNEYXRhLnJldmVudWVcclxuICAgICAgICApLFxyXG4gICAgICAgIG9yZGVyc0NoYW5nZTogdGhpcy5jYWxjdWxhdGVQZXJjZW50YWdlQ2hhbmdlKFxyXG4gICAgICAgICAgdG9kYXlTdGF0c0RhdGEub3JkZXJzLFxyXG4gICAgICAgICAgeWVzdGVyZGF5U3RhdHNEYXRhLm9yZGVyc1xyXG4gICAgICAgICksXHJcbiAgICAgICAgYXZnT3JkZXJWYWx1ZUNoYW5nZTogdGhpcy5jYWxjdWxhdGVQZXJjZW50YWdlQ2hhbmdlKFxyXG4gICAgICAgICAgdG9kYXlBdmdPcmRlclZhbHVlLFxyXG4gICAgICAgICAgeWVzdGVyZGF5QXZnT3JkZXJWYWx1ZVxyXG4gICAgICAgICksXHJcbiAgICAgICAgY3VzdG9tZXJzQ2hhbmdlOiB0aGlzLmNhbGN1bGF0ZVBlcmNlbnRhZ2VDaGFuZ2UoXHJcbiAgICAgICAgICB0b2RheVN0YXRzRGF0YS5jdXN0b21lcnMuc2l6ZSxcclxuICAgICAgICAgIHllc3RlcmRheVN0YXRzRGF0YS5jdXN0b21lcnMuc2l6ZVxyXG4gICAgICAgICksXHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyAtLS0gMi4gSW52ZW50b3J5IEFsZXJ0cyAtLS1cclxuICAgICAgY29uc3QgYXZhaWxhYmxlUHJvZHVjdHNSZXNwb25zZSA9XHJcbiAgICAgICAgYXdhaXQgcG9zU2VydmljZS5nZXRBdmFpbGFibGVQcm9kdWN0c0ZvclNhbGUoKTtcclxuICAgICAgaWYgKCFhdmFpbGFibGVQcm9kdWN0c1Jlc3BvbnNlLnN1Y2Nlc3MgfHwgIWF2YWlsYWJsZVByb2R1Y3RzUmVzcG9uc2UuZGF0YSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmZXRjaCBhdmFpbGFibGUgcHJvZHVjdHMgZm9yIGludmVudG9yeSBhbGVydHMuXCIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBpbnZlbnRvcnlBbGVydHM6IEludmVudG9yeUFsZXJ0W10gPSBbXTtcclxuICAgICAgYXZhaWxhYmxlUHJvZHVjdHNSZXNwb25zZS5kYXRhLmZvckVhY2goKHByb2R1Y3QpID0+IHtcclxuICAgICAgICBwcm9kdWN0LnZhcmlhbnRzLmZvckVhY2goKHZhcmlhbnQpID0+IHtcclxuICAgICAgICAgIGlmICh2YXJpYW50LnRvdGFsU3RvY2sgPD0gbG93U3RvY2tUaHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgaW52ZW50b3J5QWxlcnRzLnB1c2goe1xyXG4gICAgICAgICAgICAgIG1vZGVsOiBwcm9kdWN0LnByb2R1Y3ROYW1lLFxyXG4gICAgICAgICAgICAgIHZhcmlhbnQ6IGAke3ZhcmlhbnQuc3RvcmFnZUNhcGFjaXR5fSAke3ZhcmlhbnQuY29sb3JOYW1lfWAsXHJcbiAgICAgICAgICAgICAgc3RvY2s6IHZhcmlhbnQudG90YWxTdG9jayxcclxuICAgICAgICAgICAgICBzdGF0dXM6IHZhcmlhbnQudG90YWxTdG9jayA9PT0gMCA/IFwib3V0XCIgOiBcImxvd1wiLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyAtLS0gMy4gVG9wIFNlbGxpbmcgUHJvZHVjdHMgVG9kYXkgLS0tXHJcbiAgICAgIC8vIFVzaW5nIGNvbGxlY3Rpb25Hcm91cCBxdWVyeSBvbiBvcmRlciBpdGVtc1xyXG4gICAgICBjb25zdCBpdGVtc1JlZiA9IGNvbGxlY3Rpb25Hcm91cChkYiwgU1VCQ09MTEVDVElPTlMuT1JERVJfSVRFTVMpO1xyXG4gICAgICBjb25zdCBpdGVtc1F1ZXJ5ID0gcXVlcnkoXHJcbiAgICAgICAgaXRlbXNSZWYsXHJcbiAgICAgICAgd2hlcmUoXCJjcmVhdGVkQXRcIiwgXCI+PVwiLCBUaW1lc3RhbXAuZnJvbURhdGUoc3RhcnRPZlRvZGF5KSksXHJcbiAgICAgICAgd2hlcmUoXCJjcmVhdGVkQXRcIiwgXCI8PVwiLCBUaW1lc3RhbXAuZnJvbURhdGUoZW5kT2ZUb2RheSkpXHJcbiAgICAgICk7XHJcbiAgICAgIGNvbnN0IGl0ZW1zU25hcHNob3QgPSBhd2FpdCBnZXREb2NzKGl0ZW1zUXVlcnkpO1xyXG5cclxuICAgICAgY29uc3QgcHJvZHVjdFNhbGVzID0gbmV3IE1hcDxcclxuICAgICAgICBzdHJpbmcsXHJcbiAgICAgICAgeyBuYW1lOiBzdHJpbmc7IHNvbGQ6IG51bWJlcjsgcmV2ZW51ZTogbnVtYmVyIH1cclxuICAgICAgPigpO1xyXG5cclxuICAgICAgaXRlbXNTbmFwc2hvdC5kb2NzLmZvckVhY2goKGRvYykgPT4ge1xyXG4gICAgICAgIGNvbnN0IGl0ZW0gPSBkb2MuZGF0YSgpIGFzIEZpcmViYXNlU2FsZXNPcmRlckl0ZW07XHJcblxyXG4gICAgICAgIC8vIERlZmVuc2l2ZSBjaGVjazogRW5zdXJlIHRoZSBpdGVtIGFuZCBpdHMga2V5IGZpZWxkcyBhcmUgdmFsaWRcclxuICAgICAgICBpZiAoIWl0ZW0gfHwgIWl0ZW0udmFyaWFudElkIHx8ICFpdGVtLnByb2R1Y3ROYW1lKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJTa2lwcGluZyBtYWxmb3JtZWQgb3JkZXIgaXRlbSBmcm9tIEZpcmVzdG9yZTpcIiwgZG9jLmlkKTtcclxuICAgICAgICAgIHJldHVybjsgLy8gU2tpcCB0aGlzIGRvY3VtZW50XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBrZXkgPSBpdGVtLnZhcmlhbnRJZDtcclxuICAgICAgICBjb25zdCBuYW1lID0gYCR7aXRlbS5wcm9kdWN0TmFtZX0gJHtpdGVtLnN0b3JhZ2VDYXBhY2l0eSB8fCBcIlwifWA7XHJcblxyXG4gICAgICAgIGlmICghcHJvZHVjdFNhbGVzLmhhcyhrZXkpKSB7XHJcbiAgICAgICAgICBwcm9kdWN0U2FsZXMuc2V0KGtleSwgeyBuYW1lOiBuYW1lLCBzb2xkOiAwLCByZXZlbnVlOiAwIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgcHJvZHVjdCA9IHByb2R1Y3RTYWxlcy5nZXQoa2V5KSE7XHJcblxyXG4gICAgICAgIC8vIFVzZSBkZWZhdWx0IHZhbHVlIDAgaWYgcXVhbnRpdHkgb3IgZmluYWxQcmljZSBhcmUgbWlzc2luZy9mYWxzeVxyXG4gICAgICAgIHByb2R1Y3Quc29sZCArPSBpdGVtLnF1YW50aXR5IHx8IDA7XHJcbiAgICAgICAgcHJvZHVjdC5yZXZlbnVlICs9IGl0ZW0uZmluYWxQcmljZSB8fCAwO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbnN0IHRvcFByb2R1Y3RzOiBUb3BQcm9kdWN0W10gPSBBcnJheS5mcm9tKHByb2R1Y3RTYWxlcy52YWx1ZXMoKSlcclxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYi5yZXZlbnVlIC0gYS5yZXZlbnVlKVxyXG4gICAgICAgIC5zbGljZSgwLCA1KTsgLy8gR2V0IHRvcCA1XHJcblxyXG4gICAgICAvLyAtLS0gNC4gTW9udGhseSBSZXZlbnVlIC0tLVxyXG4gICAgICBjb25zdCBtb250aGx5U3RhdHMgPSBhd2FpdCB0aGlzLmdldFN0YXRzRm9yRGF0ZVJhbmdlKFxyXG4gICAgICAgIHN0YXJ0T2ZNb250aCxcclxuICAgICAgICBlbmRPZk1vbnRoXHJcbiAgICAgICk7XHJcbiAgICAgIGNvbnN0IG1vbnRobHlSZXZlbnVlOiBNb250aGx5UmV2ZW51ZSA9IHtcclxuICAgICAgICBjdXJyZW50OiBtb250aGx5U3RhdHMucmV2ZW51ZSxcclxuICAgICAgICB0YXJnZXQ6IG1vbnRobHlUYXJnZXQsXHJcbiAgICAgICAgcHJvZ3Jlc3M6XHJcbiAgICAgICAgICBtb250aGx5VGFyZ2V0ID4gMCA/IChtb250aGx5U3RhdHMucmV2ZW51ZSAvIG1vbnRobHlUYXJnZXQpICogMTAwIDogMCxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIC0tLSBDb21iaW5lIGFsbCBkYXRhIC0tLVxyXG4gICAgICBjb25zdCBkYXNoYm9hcmREYXRhOiBEYXNoYm9hcmREYXRhID0ge1xyXG4gICAgICAgIHRvZGF5U3RhdHMsXHJcbiAgICAgICAgaW52ZW50b3J5QWxlcnRzLFxyXG4gICAgICAgIHRvcFByb2R1Y3RzLFxyXG4gICAgICAgIG1vbnRobHlSZXZlbnVlLFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogZGFzaGJvYXJkRGF0YSB9O1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGRhc2hib2FyZFNlcnZpY2UgPSBuZXcgRGFzaGJvYXJkU2VydmljZSgpOyAiXSwibmFtZXMiOlsiY29sbGVjdGlvbiIsImNvbGxlY3Rpb25Hcm91cCIsInF1ZXJ5Iiwid2hlcmUiLCJnZXREb2NzIiwiVGltZXN0YW1wIiwiZGIiLCJCYXNlU2VydmljZSIsInBvc1NlcnZpY2UiLCJDT0xMRUNUSU9OUyIsIlNVQkNPTExFQ1RJT05TIiwiRGFzaGJvYXJkU2VydmljZSIsImdldFN0YXRzRm9yRGF0ZVJhbmdlIiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsIm9yZGVyc1JlZiIsIlNBTEVTX09SREVSUyIsInEiLCJmcm9tRGF0ZSIsInNuYXBzaG90IiwicmV2ZW51ZSIsImN1c3RvbWVySWRzIiwiU2V0IiwiZG9jcyIsImZvckVhY2giLCJkb2MiLCJvcmRlciIsImRhdGEiLCJ0b3RhbEFtb3VudCIsImN1c3RvbWVySWQiLCJhZGQiLCJjdXN0b21lckluZm8iLCJwaG9uZSIsIm9yZGVycyIsInNpemUiLCJjdXN0b21lcnMiLCJjYWxjdWxhdGVQZXJjZW50YWdlQ2hhbmdlIiwiY3VycmVudCIsInByZXZpb3VzIiwiZ2V0RGFzaGJvYXJkU3RhdHMiLCJsb3dTdG9ja1RocmVzaG9sZCIsIm1vbnRobHlUYXJnZXQiLCJub3ciLCJEYXRlIiwic3RhcnRPZlRvZGF5IiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsImdldERhdGUiLCJlbmRPZlRvZGF5IiwieWVzdGVyZGF5Iiwic2V0RGF0ZSIsInN0YXJ0T2ZZZXN0ZXJkYXkiLCJlbmRPZlllc3RlcmRheSIsInN0YXJ0T2ZNb250aCIsImVuZE9mTW9udGgiLCJ0b2RheVN0YXRzRGF0YSIsInllc3RlcmRheVN0YXRzRGF0YSIsIlByb21pc2UiLCJhbGwiLCJ0b2RheUF2Z09yZGVyVmFsdWUiLCJ5ZXN0ZXJkYXlBdmdPcmRlclZhbHVlIiwidG9kYXlTdGF0cyIsImF2Z09yZGVyVmFsdWUiLCJyZXZlbnVlQ2hhbmdlIiwib3JkZXJzQ2hhbmdlIiwiYXZnT3JkZXJWYWx1ZUNoYW5nZSIsImN1c3RvbWVyc0NoYW5nZSIsImF2YWlsYWJsZVByb2R1Y3RzUmVzcG9uc2UiLCJnZXRBdmFpbGFibGVQcm9kdWN0c0ZvclNhbGUiLCJzdWNjZXNzIiwiRXJyb3IiLCJpbnZlbnRvcnlBbGVydHMiLCJwcm9kdWN0IiwidmFyaWFudHMiLCJ2YXJpYW50IiwidG90YWxTdG9jayIsInB1c2giLCJtb2RlbCIsInByb2R1Y3ROYW1lIiwic3RvcmFnZUNhcGFjaXR5IiwiY29sb3JOYW1lIiwic3RvY2siLCJzdGF0dXMiLCJpdGVtc1JlZiIsIk9SREVSX0lURU1TIiwiaXRlbXNRdWVyeSIsIml0ZW1zU25hcHNob3QiLCJwcm9kdWN0U2FsZXMiLCJNYXAiLCJpdGVtIiwidmFyaWFudElkIiwiY29uc29sZSIsIndhcm4iLCJpZCIsImtleSIsIm5hbWUiLCJoYXMiLCJzZXQiLCJzb2xkIiwiZ2V0IiwicXVhbnRpdHkiLCJmaW5hbFByaWNlIiwidG9wUHJvZHVjdHMiLCJBcnJheSIsImZyb20iLCJ2YWx1ZXMiLCJzb3J0IiwiYSIsImIiLCJzbGljZSIsIm1vbnRobHlTdGF0cyIsIm1vbnRobHlSZXZlbnVlIiwidGFyZ2V0IiwicHJvZ3Jlc3MiLCJkYXNoYm9hcmREYXRhIiwiZXJyb3IiLCJoYW5kbGVFcnJvciIsImNvbnN0cnVjdG9yIiwiZGFzaGJvYXJkU2VydmljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/firebase/services/dashboard.service.ts\n"));

/***/ })

});